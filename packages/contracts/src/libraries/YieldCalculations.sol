// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

/**
 * @title YieldCalculations
 * @notice Library for yield-related calculations used across KhipuVault pools
 * @dev All functions are pure/view to ensure no state modification
 * @author KhipuVault Team
 */
library YieldCalculations {
    /// @notice Denominator for basis points calculations (100% = 10000)
    uint256 public constant BPS_DENOMINATOR = 10000;

    /// @notice Denominator for percentage calculations (100% = 100)
    uint256 public constant PERCENTAGE_DENOMINATOR = 100;

    /// @notice Denominator for share calculations (100% = 1e18 for precision)
    uint256 public constant SHARE_PRECISION = 1e18;

    /**
     * @notice Calculate user's proportional share of pool yield
     * @dev Used in both IndividualPoolV3._calculateUserYieldView and CooperativePoolV3._calculateMemberYield
     * @param poolYield Total yield generated by the pool
     * @param userDeposit User's deposit amount or shares
     * @param totalDeposited Total amount deposited in pool or total shares
     * @return userYield User's share of the yield
     */
    function calculateProportionalYield(
        uint256 poolYield,
        uint256 userDeposit,
        uint256 totalDeposited
    ) internal pure returns (uint256 userYield) {
        if (totalDeposited == 0 || userDeposit == 0) {
            return 0;
        }
        return (poolYield * userDeposit) / totalDeposited;
    }

    /**
     * @notice Calculate user's share percentage with high precision
     * @dev Used in CooperativePoolV3 for share-based calculations
     * @param userShares User's shares
     * @param totalShares Total shares in the pool
     * @return sharePercentage Share percentage scaled by SHARE_PRECISION (1e18 = 100%)
     */
    function calculateSharePercentage(
        uint256 userShares,
        uint256 totalShares
    ) internal pure returns (uint256 sharePercentage) {
        if (totalShares == 0 || userShares == 0) {
            return 0;
        }
        return (userShares * SHARE_PRECISION) / totalShares;
    }

    /**
     * @notice Calculate amount from share percentage
     * @dev Inverse operation of calculateSharePercentage
     * @param totalAmount Total amount to calculate share from
     * @param sharePercentage Share percentage scaled by SHARE_PRECISION
     * @return amount The proportional amount
     */
    function applySharePercentage(
        uint256 totalAmount,
        uint256 sharePercentage
    ) internal pure returns (uint256 amount) {
        return (totalAmount * sharePercentage) / SHARE_PRECISION;
    }

    /**
     * @notice Calculate performance fee from yield amount
     * @dev Used in both pool contracts for fee calculation
     * @param yieldAmount Total yield to calculate fee from
     * @param feeBps Fee in basis points (e.g., 100 = 1%)
     * @return feeAmount The fee to collect
     * @return netYield Yield after fee deduction
     */
    function calculatePerformanceFee(
        uint256 yieldAmount,
        uint256 feeBps
    ) internal pure returns (uint256 feeAmount, uint256 netYield) {
        if (feeBps == 0 || yieldAmount == 0) {
            return (0, yieldAmount);
        }
        feeAmount = (yieldAmount * feeBps) / BPS_DENOMINATOR;
        netYield = yieldAmount - feeAmount;
    }

    /**
     * @notice Calculate performance fee with emergency mode override
     * @dev Returns zero fee if emergency mode is active
     * @param yieldAmount Total yield to calculate fee from
     * @param feeBps Fee in basis points
     * @param emergencyMode Whether emergency mode is active
     * @return feeAmount The fee to collect (0 in emergency mode)
     * @return netYield Yield after fee deduction
     */
    function calculatePerformanceFeeWithEmergency(
        uint256 yieldAmount,
        uint256 feeBps,
        bool emergencyMode
    ) internal pure returns (uint256 feeAmount, uint256 netYield) {
        if (emergencyMode) {
            return (0, yieldAmount);
        }
        return calculatePerformanceFee(yieldAmount, feeBps);
    }

    /**
     * @notice Calculate referral bonus from deposit amount
     * @dev Used in IndividualPoolV3 referral system
     * @param depositAmount Amount being deposited
     * @param bonusBps Bonus in basis points (e.g., 50 = 0.5%)
     * @return bonusAmount The bonus to award
     * @return netDeposit Deposit after bonus deduction
     */
    function calculateReferralBonus(
        uint256 depositAmount,
        uint256 bonusBps
    ) internal pure returns (uint256 bonusAmount, uint256 netDeposit) {
        if (bonusBps == 0 || depositAmount == 0) {
            return (0, depositAmount);
        }
        bonusAmount = (depositAmount * bonusBps) / BPS_DENOMINATOR;
        netDeposit = depositAmount - bonusAmount;
    }

    /**
     * @notice Calculate APR from yield over time period
     * @dev Annualized percentage return in basis points
     * @param yieldAmount Amount of yield generated
     * @param principal Principal amount that generated the yield
     * @param durationSeconds Time period in seconds
     * @return aprBps APR in basis points (e.g., 500 = 5%)
     */
    function calculateAPR(
        uint256 yieldAmount,
        uint256 principal,
        uint256 durationSeconds
    ) internal pure returns (uint256 aprBps) {
        if (principal == 0 || durationSeconds == 0) {
            return 0;
        }
        // APR = (yield / principal) * (365 days / duration) * 10000
        uint256 secondsPerYear = 365 days;
        return (yieldAmount * secondsPerYear * BPS_DENOMINATOR) / (principal * durationSeconds);
    }

    /**
     * @notice Calculate compound yield (simple addition)
     * @dev Used for auto-compounding in IndividualPoolV3
     * @param principal Initial principal
     * @param yieldToCompound Yield amount to add
     * @return newPrincipal Principal after compounding
     */
    function compoundYield(
        uint256 principal,
        uint256 yieldToCompound
    ) internal pure returns (uint256 newPrincipal) {
        return principal + yieldToCompound;
    }

    /**
     * @notice Calculate withdrawal share for partial withdrawals
     * @dev Used in CooperativePoolV3.withdrawPartial
     * @param withdrawAmount Amount being withdrawn
     * @param totalContribution User's total contribution
     * @return withdrawShare Share percentage (scaled by SHARE_PRECISION)
     */
    function calculateWithdrawalShare(
        uint256 withdrawAmount,
        uint256 totalContribution
    ) internal pure returns (uint256 withdrawShare) {
        if (totalContribution == 0) {
            return 0;
        }
        return (withdrawAmount * SHARE_PRECISION) / totalContribution;
    }

    /**
     * @notice Calculate shares to burn based on withdrawal share
     * @dev Used in CooperativePoolV3.withdrawPartial
     * @param totalShares User's total shares
     * @param withdrawShare Withdrawal share percentage (scaled by SHARE_PRECISION)
     * @return sharesToBurn Shares to remove
     */
    function calculateSharesToBurn(
        uint256 totalShares,
        uint256 withdrawShare
    ) internal pure returns (uint256 sharesToBurn) {
        return (totalShares * withdrawShare) / SHARE_PRECISION;
    }

    /**
     * @notice Calculate minimum between two values (utility for yield caps)
     * @param a First value
     * @param b Second value
     * @return Minimum value
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @notice Calculate maximum between two values
     * @param a First value
     * @param b Second value
     * @return Maximum value
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @notice Calculate percentage of amount
     * @param amount Base amount
     * @param percentageValue Percentage (e.g., 50 = 50%)
     * @return result Amount * percentage / 100
     */
    function percentage(
        uint256 amount,
        uint256 percentageValue
    ) internal pure returns (uint256 result) {
        return (amount * percentageValue) / PERCENTAGE_DENOMINATOR;
    }

    /**
     * @notice Calculate amount from basis points
     * @param amount Base amount
     * @param bps Basis points (e.g., 500 = 5%)
     * @return result Amount * bps / 10000
     */
    function applyBasisPoints(
        uint256 amount,
        uint256 bps
    ) internal pure returns (uint256 result) {
        return (amount * bps) / BPS_DENOMINATOR;
    }
}
